// lib/pages/audio_message_builder.dart

import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_chat_types/flutter_chat_types.dart' as types;
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:http/http.dart' as http;
import 'package:audioplayers/audioplayers.dart';
import 'package:path_provider/path_provider.dart';
import 'package:intl/intl.dart';

import '../../constants/constants.dart'; // matrixBaseUrl burada tanımlı olmalı

class AudioMessageBubble extends StatefulWidget {
  final types.FileMessage message;
  final types.User currentUser;

  const AudioMessageBubble(
      this.message,
      this.currentUser, {
        Key? key,
      }) : super(key: key);

  @override
  State<AudioMessageBubble> createState() => _AudioMessageBubbleState();
}

class _AudioMessageBubbleState extends State<AudioMessageBubble> {
  bool _isDownloading = false;
  double _downloadProgress = 0.0; // 0.0 - 1.0

  bool _isPlaying = false;
  Duration _duration = Duration.zero;
  Duration _position = Duration.zero;

  late final AudioPlayer _player;
  String? _localPath;           // Dosyanın cihazda kaydedildiği tam yol
  String? _accessToken;

  StreamSubscription<PlayerState>? _stateSub;
  StreamSubscription<Duration>? _durationSub;
  StreamSubscription<Duration>? _positionSub;
  StreamSubscription<void>? _completeSub;

  @override
  void initState() {
    super.initState();
    _player = AudioPlayer();
    _readToken();
    _setupAudioListeners();
    _checkFileExists();
  }

  @override
  void dispose() {
    _stateSub?.cancel();
    _durationSub?.cancel();
    _positionSub?.cancel();
    _completeSub?.cancel();
    _player.dispose();
    super.dispose();
  }

  // SecureStorage'dan token okur
  Future<void> _readToken() async {
    _accessToken = await const FlutterSecureStorage().read(key: 'access_token');
  }

  // AudioPlayer event dinleyicileri kurulur
  void _setupAudioListeners() {
    _stateSub = _player.onPlayerStateChanged.listen((PlayerState state) {
      if (!mounted) return;
      setState(() {
        _isPlaying = (state == PlayerState.playing);
      });
    });
    _durationSub = _player.onDurationChanged.listen((dur) {
      if (!mounted) return;
      setState(() {
        _duration = dur;
      });
    });
    _positionSub = _player.onPositionChanged.listen((pos) {
      if (!mounted) return;
      setState(() {
        _position = pos;
      });
    });
    _completeSub = _player.onPlayerComplete.listen((_) {
      if (!mounted) return;
      setState(() {
        _isPlaying = false;
        _position = Duration.zero;
      });
    });
  }

  // MXC formatını HTTP indirme URL'sine dönüştürür
  String _mxcToUrl(String mxcUrl, String baseUrl) {
    final cleaned = mxcUrl.replaceFirst('mxc://', '');
    return '$baseUrl/_matrix/media/r0/download/$cleaned';
  }

  // Gelen FileMessage içinden uzantıyı (extension) çıkarır
  String _getFileExtension(String filename) {
    final dotIndex = filename.lastIndexOf('.');
    if (dotIndex >= 0 && dotIndex < filename.length - 1) {
      return filename.substring(dotIndex + 1);
    }
    return ''; // Uzantı yoksa boş döner
  }

  /// Cihazda dosya var mı diye kontrol eder
  Future<void> _checkFileExists() async {
    final dir = await getTemporaryDirectory();

    // 1) FileMessage.id kullanarak benzersiz dosya adı oluştur:
    final ext = _getFileExtension(widget.message.name);
    final uniqueFilename = widget.message.id + (ext.isNotEmpty ? '.$ext' : '');

    // 2) Tam yol:
    final filePath = '${dir.path}/$uniqueFilename';
    final file = File(filePath);

    final exists = await file.exists();
    if (exists) {
      setState(() {
        _localPath = filePath;
      });
      // Eğer dosya varsa, süre bilgisini almayı dene ama 30 sn timeout'u patlatırsa yakala
      try {
        await _player.setSource(DeviceFileSource(filePath));
        // Süreyi hemen al (zaman aşımı olabilir, o yüzden try/catch içinde)
        final d = await _player.getDuration().timeout(
          const Duration(seconds: 30),
          onTimeout: () => Duration.zero,
        );
        if (!mounted) return;
        setState(() {
          _duration = d ?? Duration.zero;
        });
      } catch (e) {
        // Hata veya timeout olursa süreyi sıfır bırak, çökmesini engelle
        if (!mounted) return;
        setState(() {
          _duration = Duration.zero;
        });
      }
    }
  }

  /// İndirme işlemini başlatır ve ilerlemeyi günceller
  Future<void> _downloadFile() async {
    if (_isDownloading || _localPath != null) return;
    if (_accessToken == null) {
      await _readToken();
      if (_accessToken == null) return;
    }

    setState(() {
      _isDownloading = true;
      _downloadProgress = 0.0;
    });

    try {
      final uri = Uri.parse(
        '${_mxcToUrl(widget.message.uri, matrixBaseUrl)}?access_token=$_accessToken',
      );
      final request = http.Request('GET', uri);
      final client = http.Client();
      final streamedResponse = await client.send(request);

      final contentLength = streamedResponse.contentLength ?? 0;
      int bytesReceived = 0;

      final dir = await getTemporaryDirectory();
      final ext = _getFileExtension(widget.message.name);
      final uniqueFilename = widget.message.id + (ext.isNotEmpty ? '.$ext' : '');
      final filePath = '${dir.path}/$uniqueFilename';

      final file = File(filePath);
      final sink = file.openWrite();

      await streamedResponse.stream.listen(
            (chunk) {
          sink.add(chunk);
          bytesReceived += chunk.length;
          if (contentLength > 0) {
            if (mounted) {
              setState(() {
                _downloadProgress = bytesReceived / contentLength;
              });
            }
          }
        },
        onDone: () async {
          await sink.flush();
          await sink.close();
          if (!mounted) return;
          setState(() {
            _localPath = filePath;
            _isDownloading = false;
            _downloadProgress = 0.0;
          });
          // İndirilen dosyayla ses oynatıcıyı güncelle, süreyi almak isteğe bağlı
          try {
            await _player.setSource(DeviceFileSource(filePath));
            final dur = await _player.getDuration().timeout(
              const Duration(seconds: 30),
              onTimeout: () => Duration.zero,
            );
            if (!mounted) return;
            setState(() {
              _duration = dur ?? Duration.zero;
            });
          } catch (e) {
            if (!mounted) return;
            setState(() {
              _duration = Duration.zero;
            });
          }
        },
        onError: (e) async {
          await sink.close();
          if (await file.exists()) {
            await file.delete();
          }
          if (!mounted) return;
          setState(() {
            _isDownloading = false;
            _downloadProgress = 0.0;
          });
        },
        cancelOnError: true,
      );
    } catch (e) {
      print('İndirme hatası: $e');
      if (!mounted) return;
      setState(() {
        _isDownloading = false;
        _downloadProgress = 0.0;
      });
    }
  }

  /// Play / Pause toggle
  Future<void> _togglePlayPause() async {
    if (_localPath == null) return;
    if (_isPlaying) {
      await _player.pause();
    } else {
      await _player.play(DeviceFileSource(_localPath!));
    }
  }

  /// Süreyi "mm:ss" formatına çevirir
  String _formatDuration(Duration d) {
    final minutes = d.inMinutes.remainder(60).toString().padLeft(2, '0');
    final seconds = d.inSeconds.remainder(60).toString().padLeft(2, '0');
    return '$minutes:$seconds';
  }

  @override
  Widget build(BuildContext context) {
    final isMe = widget.message.author.id == widget.currentUser.id;
    final screenWidth = MediaQuery.of(context).size.width;

    return Align(
      alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 12),
        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12),
        decoration: BoxDecoration(
          color: isMe ? Colors.green[600] : Colors.grey[300],
          borderRadius: BorderRadius.only(
            topLeft: const Radius.circular(16),
            topRight: const Radius.circular(16),
            bottomLeft: Radius.circular(isMe ? 16 : 0),
            bottomRight: Radius.circular(isMe ? 0 : 16),
          ),
        ),
        constraints: BoxConstraints(
          maxWidth: screenWidth * 0.75,
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment:
          isMe ? CrossAxisAlignment.end : CrossAxisAlignment.start,
          children: [
            // 1) İndirme Durumunu Yöneten Buton/Bar
            if (_localPath == null && !_isDownloading)
              IconButton(
                icon: const Icon(Icons.download_rounded, color: Colors.white),
                onPressed: _downloadFile,
              ),

            if (_isDownloading)
              Padding(
                padding: const EdgeInsets.symmetric(vertical: 4.0),
                child: LinearProgressIndicator(
                  value: _downloadProgress,
                  backgroundColor: Colors.white24,
                  valueColor:
                  AlwaysStoppedAnimation<Color>(Colors.lightGreenAccent),
                ),
              ),

            // 2) Eğer dosya indirilmişse Play/Pause + Slider göster
            if (_localPath != null)
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  IconButton(
                    icon: Icon(
                      _isPlaying ? Icons.pause : Icons.play_arrow,
                      color: Colors.white,
                    ),
                    onPressed: _togglePlayPause,
                  ),
                  Expanded(
                    child: SliderTheme(
                      data: SliderTheme.of(context).copyWith(
                        trackHeight: 3,
                        thumbShape: const RoundSliderThumbShape(
                          enabledThumbRadius: 6,
                        ),
                      ),
                      child: Slider(
                        activeColor: Colors.white,
                        inactiveColor: Colors.white30,
                        min: 0,
                        max: _duration.inMilliseconds.toDouble(),
                        value: _position.inMilliseconds
                            .clamp(0, _duration.inMilliseconds)
                            .toDouble(),
                        onChanged: (value) async {
                          final newPos = Duration(milliseconds: value.toInt());
                          await _player.seek(newPos);
                        },
                      ),
                    ),
                  ),
                ],
              ),

            // 3) Alt Kısım: Kalan Süre / Toplam Süre
            if (_localPath != null)
              Padding(
                padding: const EdgeInsets.only(top: 4.0),
                child: Text(
                  '${_formatDuration(_position)} / ${_formatDuration(_duration)}',
                  style: TextStyle(
                    color: isMe ? Colors.white70 : Colors.black87,
                    fontSize: 12,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}
